// Refactored Fish Feeder Sketch with Dynamic Reply and Test Mode
#include <SoftwareSerial.h>
#include <HX711_ADC.h>
#include <Servo.h>
#include <RTClib.h>
#include <EEPROM.h>

// Uncomment to enable Test Mode
//#define TEST_MODE
 
// Pin Definitions
constexpr uint8_t GSM_RX_PIN       = 10;
constexpr uint8_t GSM_TX_PIN       = 11;
constexpr uint8_t SERVO_PIN        = 9;
constexpr uint8_t LOADCELL_DOUT    = 4;
constexpr uint8_t LOADCELL_SCK     = 5;
constexpr uint8_t RELAY_PIN        = 6;

// Configuration Constants
constexpr uint8_t  MAX_SCHEDULES      = 10;
constexpr int      EEPROM_BASE_ADDR   = 0;
constexpr int      LOG_BASE_ADDR      = 500;  // Start logs after schedule data
constexpr uint8_t  MAX_LOG_ENTRIES    = 20;
constexpr uint8_t  LOG_ENTRY_SIZE     = 80;
constexpr float    CALIBRATION_FACTOR = -7050.0f;
constexpr uint16_t CELL_STABLE_MS     = 2000;
constexpr uint16_t LOADCELL_UPDATE_MS = 250;

// Schedule structure
struct FeedingSchedule {
  uint8_t  hour;
  uint8_t  minute;
  float    amount;
  bool     active;
  uint32_t startDay;
  uint32_t endDay;
};

// Globals
SoftwareSerial gsm(GSM_RX_PIN, GSM_TX_PIN);
HX711_ADC       scale(LOADCELL_DOUT, LOADCELL_SCK);
Servo            servo;
RTC_DS3231       rtc;
FeedingSchedule  schedules[MAX_SCHEDULES];
uint8_t          scheduleCount = 0;
float            currentWeight  = 0;
String           lastSender     = "";
unsigned long    lastLoadcellMS = 0;
uint8_t          logIndex = 0;

// Incoming SMS assembly state
String           pendingSMSHeader = "";
String           pendingSMSBody   = "";
bool             awaitingSMSBody  = false;
unsigned long    smsLastByteMs    = 0;
String           aggSender        = "";

// Forward declarations
void loadSchedules();
void saveSchedules();
void printSchedulesFromEEPROM();
void setupGSM();
void sendAT(const char* cmd);
void sendSMS(const String& to, const String& text);
void checkSMS();
void handleCMTI(const String& line);
void readSMSByIndex(int index);
void processSMS(const String& header, const String& msg);
void checkFeed();
uint32_t dateToDays(int y, int m, int d);
uint32_t parseDate(const String&);
void dispense(float grams);
void logMessage(const String& msg);
void printLogs();
void clearLogs();

void setup() {
  Serial.begin(9600);
  gsm.begin(9600);
  gsm.setTimeout(5000);

  #ifdef TEST_MODE
    Serial.println(F("TEST_MODE IS ACTIVE"));
  #else
    Serial.println(F("TEST_MODE IS INACTIVE"));
  #endif

  if (!rtc.begin()) {
    Serial.println(F("RTC not found"));
    while (true);
  }

  scale.begin();
  scale.start(CELL_STABLE_MS);
  scale.setCalFactor(CALIBRATION_FACTOR);

  servo.attach(SERVO_PIN);
  servo.write(0);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, LOW);

  loadSchedules();
  printSchedulesFromEEPROM();
  
  // Load log index
  EEPROM.get(LOG_BASE_ADDR, logIndex);
  if (logIndex > MAX_LOG_ENTRIES) logIndex = 0;
  
  // Print existing logs
  printLogs();
  
  setupGSM();

  Serial.println(F("=== Fish Feeder Initialized ==="));

#ifdef TEST_MODE
  String testHeader = "+CMT: \"+1234567890\",,\"24/07/25,16:00:00+08\"";
  String testMessage =
    "New feeding schedule for Tilapia\n\n"
    "Jul 24, 2025 - Jul 30, 2025:\n"
    "• 4:00 PM - 5.0g\n"
    "• 7:00 PM - 10.0g\n"
    "• 6:00 AM - 15.0g";
  processSMS(testHeader, testMessage);
#endif
}

void loop() {
#ifndef TEST_MODE
  unsigned long now = millis();
  if (now - lastLoadcellMS >= LOADCELL_UPDATE_MS) {
    scale.update();
    currentWeight = scale.getData();
    lastLoadcellMS = now;
  }
  
  // Check for user commands when connected to laptop
  if (Serial.available()) {
    String cmd = Serial.readString();
    cmd.trim();
    if (cmd == "LOGS") {
      printLogs();
    } else if (cmd == "CLEAR") {
      clearLogs();
      Serial.println("Logs cleared!");
    } else if (cmd == "STATUS") {
      sendAT("AT+CREG?");
      sendAT("AT+CSQ");
    }
  }
  
  // Monitor network status every 2 minutes
  static unsigned long lastStatusCheck = 0;
  if (millis() - lastStatusCheck > 120000) { // 2 minutes
    DateTime now = rtc.now();
    String timeStr = String(now.hour()) + ":" + String(now.minute());
    
    // Check network status
    gsm.println("AT+CREG?");
    delay(500);
    String regResponse = "";
    while (gsm.available()) {
      regResponse += (char)gsm.read();
    }
    
    gsm.println("AT+CSQ");
    delay(500);
    String sigResponse = "";
    while (gsm.available()) {
      sigResponse += (char)gsm.read();
    }
    
    // Log network status
    if (regResponse.indexOf("+CREG:") >= 0) {
      logMessage(timeStr + " REG:" + regResponse.substring(regResponse.indexOf("+CREG:"), regResponse.indexOf("+CREG:") + 15));
    }
    if (sigResponse.indexOf("+CSQ:") >= 0) {
      logMessage(timeStr + " SIG:" + sigResponse.substring(sigResponse.indexOf("+CSQ:"), sigResponse.indexOf("+CSQ:") + 12));
    }
    
    lastStatusCheck = millis();
  }
  
  checkSMS();
  checkFeed();
#endif
}

void setupGSM() {
  Serial.println(F("Setting up GSM..."));
  
  const char* cmds[] = {
    "AT", 
    "AT+CMGF=1", 
    "AT+CNMI=2,1,0,0,0", 
    "AT+CMGDA=\"DEL ALL\"",
    "AT+CREG?",     // Network registration status
    "AT+CSQ",       // Signal quality
    "AT+CPIN?",     // SIM card status
    "AT+CCID"       // SIM card ID
  };
  
  for (auto cmd : cmds) {
    Serial.print(F("Sending: "));
    Serial.println(cmd);
    sendAT(cmd);
    delay(1000);  // Increased delay
  }
  
  Serial.println(F("GSM setup complete"));
}

void sendAT(const char* cmd) {
  gsm.println(cmd);
  delay(500);  // Give more time for response
  
  Serial.print(F("Response: "));
  String response = "";
  unsigned long timeout = millis() + 2000; // 2 second timeout
  
  while (millis() < timeout) {
    if (gsm.available()) {
      char c = gsm.read();
      Serial.write(c);
      response += c;
    }
  }
  
  if (response.length() == 0) {
    Serial.println(F("NO RESPONSE!"));
  }
  
  Serial.println();
}

void sendSMS(const String& to, const String& text) {
  sendAT("AT+CMGF=1");
  String cmd = "AT+CMGS=\"" + to + "\"";
  sendAT(cmd.c_str());
  gsm.print(text);
  gsm.write(26);
  delay(500);
}

void checkSMS() {
  // Read line-by-line to assemble header and body across short gaps
  while (gsm.available()) {
    String line = gsm.readStringUntil('\n');
    line.trim();
    if (line.length() == 0) { continue; }
    logMessage("SMS check - data available");

    // Prefer memory indication path: +CMTI: "SM",<index>
    if (line.startsWith("+CMTI:")) {
      handleCMTI(line);
      continue;
    }

    if (line.startsWith("+CMT:")) {
      // Parse sender from this header
      int p1 = line.indexOf('"');
      int p2 = line.indexOf('"', p1 + 1);
      String newSender = "";
      if (p1 >= 0 && p2 > p1) {
        newSender = line.substring(p1 + 1, p2);
      }

      // If we were already assembling a message and a new header arrives
      if (awaitingSMSBody) {
        if (newSender.length() && newSender == aggSender) {
          // Continuation segment from same sender: keep aggregating
          smsLastByteMs = millis();
          // Add a safe separator so segments don't join words
          if (pendingSMSBody.length() && pendingSMSBody[pendingSMSBody.length()-1] != '\n') {
            pendingSMSBody += '\n';
          }
          // Do NOT clear body; wait for following lines to append
        } else {
          // Different sender or unknown: finalize previous body first
          String msg = pendingSMSBody; msg.trim();
          if (msg.length()) {
            Serial.print(F("SMS BODY LEN=")); Serial.println(msg.length());
            Serial.println(F("--- SMS BODY START ---")); Serial.println(msg); Serial.println(F("--- SMS BODY END ---"));
            logMessage("Msg: " + msg.substring(0, min(50, (int)msg.length())));
            processSMS(pendingSMSHeader, msg);
          }
          // Reset aggregator
          awaitingSMSBody = false;
          pendingSMSHeader = "";
          pendingSMSBody = "";
          aggSender = "";
        }
      }

      // Start (or continue) a new aggregation window for this sender
      pendingSMSHeader = line;
      awaitingSMSBody = true;
      if (aggSender.length() == 0) aggSender = newSender;
      lastSender = newSender;
      smsLastByteMs = millis();

      logMessage("SMS header found!");
      if (newSender.length()) {
        logMessage("Sender: " + newSender);
      } else {
        logMessage("ERROR: Could not extract sender");
      }
    } else if (awaitingSMSBody) {
      // Accumulate SMS body lines
      pendingSMSBody += line;
      pendingSMSBody += '\n';
      smsLastByteMs = millis();
    }
  }

  // If we were gathering a body and things have been idle for a while, process it
  if (awaitingSMSBody && (millis() - smsLastByteMs) > 5000) {
    String msg = pendingSMSBody;
    msg.trim();

    // Serial-only diagnostics
    Serial.print(F("SMS BODY LEN="));
    Serial.println(msg.length());
    Serial.println(F("--- SMS BODY START ---"));
    Serial.println(msg);
    Serial.println(F("--- SMS BODY END ---"));

    logMessage("Msg: " + msg.substring(0, min(50, (int)msg.length())));
    processSMS(pendingSMSHeader, msg);

    // Reset state
    awaitingSMSBody = false;
    pendingSMSHeader = "";
    pendingSMSBody = "";
    aggSender = "";
  }
}

void handleCMTI(const String& line) {
  // Format: +CMTI: "SM",12
  int comma = line.lastIndexOf(',');
  if (comma < 0) return;
  int idx = line.substring(comma + 1).toInt();
  if (idx <= 0) return;
  readSMSByIndex(idx);
}

void readSMSByIndex(int index) {
  // Read the full SMS reliably using CMGR
  String cmd = "AT+CMGR=" + String(index);
  gsm.println(cmd);

  String header = "";
  String body = "";
  bool headerSeen = false;
  unsigned long start = millis();
  while (millis() - start < 8000) { // up to 8s to read
    String line = gsm.readStringUntil('\n');
    line.trim();
    if (line.length() == 0) continue;
    if (!headerSeen) {
      if (line.startsWith("+CMGR:")) {
        header = line;
        headerSeen = true;
        // Extract sender (3rd-4th quotes)
        int q[8]; int qi = 0; int pos = -1;
        while (qi < 8) {
          pos = header.indexOf('"', pos + 1);
          if (pos < 0) break; q[qi++] = pos;
        }
        if (qi >= 4) {
          String sender = header.substring(q[2] + 1, q[3]);
          if (sender.length()) {
            lastSender = sender;
            logMessage("Sender: " + sender);
          }
        }
      }
    } else {
      if (line == "OK") break;
      body += line;
      body += '\n';
    }
  }

  body.trim();
  Serial.print(F("SMS BODY LEN=")); Serial.println(body.length());
  Serial.println(F("--- SMS BODY START ---")); Serial.println(body); Serial.println(F("--- SMS BODY END ---"));
  if (body.length()) {
    logMessage("Msg: " + body.substring(0, min(50, (int)body.length())));
    processSMS(header, body);
  } else {
    logMessage("ERROR: CMGR returned empty body");
  }

  // Optionally delete the message to avoid re-reading
  gsm.print(F("AT+CMGD=")); gsm.println(index);
  delay(200);
  unsigned long t = millis();
  while (millis() - t < 500) { if (gsm.available()) (void)gsm.read(); }
}

void processSMS(const String& header, const String& msg) {
  logMessage("Processing SMS...");
  
  // Accept messages that begin with "New feeding" (case-insensitive)
  String msgUpper = msg;
  msgUpper.trim();
  msgUpper.toUpperCase();
  if (!msgUpper.startsWith("NEW FEEDING")) {
    logMessage("ERROR: Wrong format (expected to start with 'New feeding')");
    return;
  }

  logMessage("SMS format OK");
  scheduleCount = 0;
  String text = msg;
  text.replace("\r", "");

  // Parse date range
  static const char* MONTHS[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  int dateStart = -1;
  for (int i = 0; i < 12; i++) {
    int idx = text.indexOf(MONTHS[i]);
    if (idx >= 0) { dateStart = idx; break; }
  }
  
  // Look for the end of date range - find the line that ends with colon
  int dateEnd = -1;
  if (dateStart >= 0) {
    int searchPos = dateStart;
    while (searchPos < text.length()) {
      int lineEnd = text.indexOf('\n', searchPos);
      if (lineEnd < 0) lineEnd = text.length();
      
      String line = text.substring(searchPos, lineEnd);
      line.trim();
      if (line.endsWith(":")) {
        dateEnd = lineEnd;
        break;
      }
      searchPos = lineEnd + 1;
    }
  }
  
  if (dateStart >= 0 && dateEnd > dateStart) {
    String dateLine = text.substring(dateStart, dateEnd);
    dateLine.replace(":", ""); // Remove the colon
    dateLine.trim();
    logMessage("Date: " + dateLine.substring(0, min(30, (int)dateLine.length())));
    
    int dashPos = dateLine.indexOf("-");
    if (dashPos > 0) {
      String startDate = dateLine.substring(0, dashPos);
      String endDate = dateLine.substring(dashPos + 1);
      startDate.trim();
      endDate.trim();
      
      uint32_t startDay = parseDate(startDate);
      uint32_t endDay = parseDate(endDate);
      
      logMessage("Parsed start day: " + String(startDay) + ", end day: " + String(endDay));
      
      // Find all schedule lines - look for lines starting with "- " after the date
      int searchPos = dateEnd + 1;
      while (searchPos < text.length() && scheduleCount < MAX_SCHEDULES) {
        int lineStart = searchPos;
        int lineEnd = text.indexOf('\n', searchPos);
        if (lineEnd < 0) lineEnd = text.length();
        
        String line = text.substring(lineStart, lineEnd);
        line.trim();
        
        // Check if this line is a schedule entry (starts with "- ")
        if (line.startsWith("- ")) {
          line = line.substring(2); // Remove "- " prefix
          line.trim();
          
          logMessage("Processing schedule line: " + line);
          
          // Find the dash that separates time from amount
          int timeDashPos = line.indexOf(" - ");
          if (timeDashPos > 0) {
            String timePart = line.substring(0, timeDashPos);
            String amountPart = line.substring(timeDashPos + 3);
            
            timePart.trim();
            amountPart.trim();
            
            logMessage("Time: '" + timePart + "', Amount: '" + amountPart + "'");
            
            // Parse time with AM/PM
            String upperTime = timePart;
            upperTime.toUpperCase();
            
            bool isPM = upperTime.indexOf("PM") >= 0;
            bool isAM = upperTime.indexOf("AM") >= 0;
            
            // Remove AM/PM from time string
            timePart.replace(" PM", "");
            timePart.replace(" AM", "");
            timePart.replace(" pm", "");
            timePart.replace(" am", "");
            timePart.trim();
            
            int colonPos = timePart.indexOf(':');
            if (colonPos >= 0) {
              int hour = timePart.substring(0, colonPos).toInt();
              int minute = timePart.substring(colonPos + 1).toInt();
              
              if (isPM && hour != 12) hour += 12;
              if (isAM && hour == 12) hour = 0;
                
              amountPart.replace("g", "");
              float amount = amountPart.toFloat();
              
              if (amount > 0) { // Only add if we got a valid amount
                // Display in 12-hour format
                int displayHour = hour;
                String period = "AM";
                if (hour >= 12) {
                  period = "PM";
                  if (hour > 12) displayHour = hour - 12;
                }
                if (hour == 0) {
                  displayHour = 12;
                  period = "AM";
                }
                
                String schedMsg = "Added: " + String(displayHour) + ":" + (minute<10?"0":"") + String(minute) + " " + period + " - " + String(amount) + "g";
                logMessage(schedMsg);
                
                schedules[scheduleCount++] = { 
                  uint8_t(hour), 
                  uint8_t(minute), 
                  amount, 
                  true, 
                  startDay, 
                  endDay 
                };
              } else {
                logMessage("ERROR: Invalid amount parsed: " + amountPart);
              }
            } else {
              logMessage("ERROR: No colon found in time: " + timePart);
            }
          } else {
            logMessage("ERROR: No time-amount separator found in: " + line);
          }
        }
        
        searchPos = lineEnd + 1;
      }
    }
  } else {
    logMessage("ERROR: No date range found");
  }
  
  if (scheduleCount > 0) {
    saveSchedules();
    if (lastSender.length()) {
      logMessage("Sending confirmation to: " + lastSender);
      sendSMS(lastSender, "Feeding schedule updated successfully!");
    } else {
      logMessage("ERROR: No sender for confirmation");
    }
  } else {
    logMessage("No schedules parsed; skipping save/confirmation");
  }
}

void checkFeed() {
  DateTime now = rtc.now();
  uint32_t today = dateToDays(now.year(), now.month(), now.day());

  for (uint8_t i = 0; i < scheduleCount; i++) {
    auto& sc = schedules[i];
    if (!sc.active || today < sc.startDay || today > sc.endDay) continue;

    if (now.hour() == sc.hour && now.minute() == sc.minute && now.second() < 5) {
      dispense(sc.amount);
      if (lastSender.length()) {
        String msg = "Fed " + String(sc.amount) + "g at " + String(sc.hour) + ":" + (sc.minute<10?"0":"") + String(sc.minute);
        sendSMS(lastSender, msg);
      }
      delay(1000);
    }
  }
}

void dispense(float grams) {
  constexpr float GRAMS_PER_SEC = 1.0f;
  unsigned long runMs = (unsigned long)(grams / GRAMS_PER_SEC * 1000);
  servo.write(90);
  delay(runMs);
  servo.write(0);
}

void saveSchedules() {
  EEPROM.put(EEPROM_BASE_ADDR, scheduleCount);
  for (uint8_t i = 0; i < scheduleCount; i++) {
    EEPROM.put(EEPROM_BASE_ADDR + 1 + i * sizeof(FeedingSchedule), schedules[i]);
  }
}

void loadSchedules() {
  EEPROM.get(EEPROM_BASE_ADDR, scheduleCount);
  if (scheduleCount > MAX_SCHEDULES) scheduleCount = 0;
  for (uint8_t i = 0; i < scheduleCount; i++) {
    EEPROM.get(EEPROM_BASE_ADDR + 1 + i * sizeof(FeedingSchedule), schedules[i]);
  }
}

void printSchedulesFromEEPROM() {
  Serial.println(F("\n--- Schedules in EEPROM ---"));
  Serial.print(F("Schedule Count: ")); Serial.println(scheduleCount);
  for (uint8_t i = 0; i < scheduleCount; i++) {
    FeedingSchedule sc;
    EEPROM.get(EEPROM_BASE_ADDR + 1 + i * sizeof(FeedingSchedule), sc);
    Serial.print(F("Schedule ")); Serial.print(i + 1); Serial.print(F(": "));
    // Display in 12-hour format
    int displayHour = sc.hour;
    String period = "AM";
    if (sc.hour >= 12) {
      period = "PM";
      if (sc.hour > 12) displayHour = sc.hour - 12;
    }
    if (sc.hour == 0) {
      displayHour = 12;
      period = "AM";
    }
    Serial.print(displayHour); Serial.print(":" );
    if (sc.minute < 10) Serial.print("0"); Serial.print(sc.minute);
    Serial.print(' '); Serial.print(period);
    Serial.print(F(" — ")); Serial.print(sc.amount); Serial.print(F("g "));
    DateTime startDT(sc.startDay * 86400);
    DateTime endDT(sc.endDay * 86400);
    Serial.print(F("["));
    Serial.print(startDT.year()); Serial.print("-");
    Serial.print(startDT.month() < 10 ? "0" : ""); Serial.print(startDT.month()); Serial.print("-");
    Serial.print(startDT.day() < 10 ? "0" : ""); Serial.print(startDT.day());
    Serial.print(F(" to "));
    Serial.print(endDT.year()); Serial.print("-");
    Serial.print(endDT.month() < 10 ? "0" : ""); Serial.print(endDT.month()); Serial.print("-");
    Serial.print(endDT.day() < 10 ? "0" : ""); Serial.print(endDT.day());
    Serial.println(F("]"));
  }
  Serial.println(F("---------------------------"));
}

uint32_t dateToDays(int y, int m, int d) {
  DateTime dt(y, m, d, 0, 0, 0);
  return dt.unixtime() / 86400;
}

uint32_t parseDate(const String& s) {
  static const char* M[] = {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
  String str = s;
  str.trim();

  // Find month token anywhere in the string
  int mon = 1;
  int monPos = -1;
  for (int i = 0; i < 12; i++) {
    int pos = str.indexOf(M[i]);
    if (pos >= 0) { mon = i + 1; monPos = pos; break; }
  }

  // After month, skip spaces/commas then read day digits
  int i = (monPos >= 0) ? monPos + 3 : 0;
  while (i < (int)str.length() && (str[i] == ' ' || str[i] == ',')) i++;
  int dayStart = i;
  while (i < (int)str.length() && (str[i] >= '0' && str[i] <= '9')) i++;
  int day = str.substring(dayStart, i).toInt();

  // Find year: first 4+ digit number after day
  while (i < (int)str.length() && !(str[i] >= '0' && str[i] <= '9')) i++;
  int yearStart = i;
  while (i < (int)str.length() && (str[i] >= '0' && str[i] <= '9')) i++;
  int year = str.substring(yearStart, i).toInt();

  if (day <= 0 || year <= 0) {
    // Fallback to original naive parsing if something went wrong
    if (str.length() >= 12) {
      int d = str.substring(4, 6).toInt();
      int y = str.substring(8, 12).toInt();
      if (d > 0 && y > 0) return dateToDays(y, mon, d);
    }
  }
  return dateToDays(year, mon, day);
}

void logMessage(const String& msg) {
  // Get current time
  DateTime now = rtc.now();
  String timeStr = String(now.hour()) + ":" + (now.minute()<10?"0":"") + String(now.minute()) + " ";
  
  // Prepare log entry (time + message, max 80 chars)
  String logEntry = timeStr + msg;
  if (logEntry.length() > LOG_ENTRY_SIZE-1) {
    logEntry = logEntry.substring(0, LOG_ENTRY_SIZE-1);
  }
  
  // Calculate EEPROM address
  int addr = LOG_BASE_ADDR + 1 + (logIndex * LOG_ENTRY_SIZE);
  
  // Write to EEPROM
  for (int i = 0; i < LOG_ENTRY_SIZE; i++) {
    if (i < logEntry.length()) {
      EEPROM.write(addr + i, logEntry[i]);
    } else {
      EEPROM.write(addr + i, 0); // Null terminator
    }
  }
  
  // Update log index
  logIndex = (logIndex + 1) % MAX_LOG_ENTRIES;
  EEPROM.put(LOG_BASE_ADDR, logIndex);
  
  // Also print to Serial if connected
  Serial.println("LOG: " + logEntry);
}

void printLogs() {
  Serial.println(F("\n=== STORED LOGS ==="));
  
  // Read log index
  uint8_t currentIndex;
  EEPROM.get(LOG_BASE_ADDR, currentIndex);
  if (currentIndex > MAX_LOG_ENTRIES) currentIndex = 0;
  
  // Print logs in order (oldest first)
  for (int i = 0; i < MAX_LOG_ENTRIES; i++) {
    int logNum = (currentIndex + i) % MAX_LOG_ENTRIES;
    int addr = LOG_BASE_ADDR + 1 + (logNum * LOG_ENTRY_SIZE);
    
    // Read log entry
    String logEntry = "";
    for (int j = 0; j < LOG_ENTRY_SIZE; j++) {
      char c = EEPROM.read(addr + j);
      if (c == 0) break; // Null terminator
      logEntry += c;
    }
    
    if (logEntry.length() > 0) {
      Serial.print(F("LOG "));
      Serial.print(i + 1);
      Serial.print(F(": "));
      Serial.println(logEntry);
    }
  }
  Serial.println(F("=== END LOGS ==="));
  Serial.println(F("Commands: LOGS (show logs), CLEAR (clear logs), STATUS (check network)"));
}

void clearLogs() {
  logIndex = 0;
  EEPROM.put(LOG_BASE_ADDR, logIndex);
  
  // Clear all log entries
  for (int i = 0; i < MAX_LOG_ENTRIES * LOG_ENTRY_SIZE; i++) {
    EEPROM.write(LOG_BASE_ADDR + 1 + i, 0);
  }
}